## 💡WAS(Web Application Server)와 WS(Web Server)의 차이를 설명해주세요.

- WAS(Web Application Server) : 비즈니스 로직을 넣을 수 있음
    - Tomcat, PHP, ASP, .NET 등
- WS(Web Server) : 비즈니스 로직을 넣을 수 없음
    - Nginx, Apache 등

---

## 💡Spring Framework에 대해 설명해주세요.

- 스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크 입니다.
- 경량 컨테이너로서 자바 객체를 직접 관리
    - 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
- 제어의 역전(IoC)이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모
    - 컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.
- 의존성 주입(DI, Dependency Injection)을 지원
    - 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
- 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 지원
    - 트랜잭션이나 로깅, 보안과 같이여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.

---

## 💡Spring Boot와 Spring Framework의 차이점을 설명해주세요.

- 가장 큰 차이점은 Auto Configuration의 차이인 것 같습니다.
- Spring은 프로젝트 초기에 다양한 환경설정을 해야 하지만,Spring Boot는 설정의 많은 부분을 자동화하여 사용자가 편하게 스프링을 활용할 수 있도록 돕습니다.
- spring boot starter dependency만 추가해주면 설정은 끝나고, 내장된 톰캣을 제공해 서버를 바로 실행할 수 있습니다

---

## 💡Spring MVC에 대해 설명해주세요.

- MVC는 Model, View, Controller의 약자이며, 각 레이어간 기능을 구분하는데 중점을 둔 디자인 패턴입니다.
- Model
    - 데이터 관리 및 비즈니스 로직을 처리하는 부분이며, (DAO, DTO, Service 등)
- View
    - 비즈니스 로직의 처리 결과를 통해 유저 인터페이스가 표현되는 구간입니다. (html, jsp, tymeleaf, mustache 등 화면을 구성하기도 하고, Rest API로 서버가 구현된다면 json 응답으로 구성되기도 한다.)
- Controller
    - 사용자의 요청을 처리하고 Model과 View를 중개하는 역할을 합니다.
    - Model과 View는 서로 연결되어 있지 않기 때문에 Controller가 사이에서 통신 매체가 되어줍니다.

---

## 💡MVC는 어떠한 흐름으로 요청을 처리하는지 설명해주세요.

- DispatcherServlet : 클라이언트에게 요청을 받아 응답까지의 MVC 처리 과정을 통제한다.
- HandlerMapping : 클라이언트의 요청 URL을 어떤 Controller가 처리할지 결정한다.
- HandlerAdapter : HandlerMapping에서 결정된 핸들러 정보로 해당 메소드를 직접 호출해주는 역할을 한다.
- ViewResolver : Controller의 처리 결과(데이터)를 생성할 view를 결정한다.
- 처리 과정
    1. 클라이언트는 URL을 통해 요청을 전송한다.
    2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다.
    3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다.
    4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다.
    5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다.
    6. 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다.
    7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다.
    8. 데이터가 추가된 뷰를 반환한다.

---

## 💡제어의 역전(IoC, Inversion of Control)에 대해 아는대로 설명해주세요.

- 제어의 역전(IoC)이란, 모든 객체에 대한(생성, 라이프사이클 등) 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴 것을 말합니다.
- 스프링에서는 IoC 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입(DI, Dependency Injection)하는 역할을 하고, 컨테이너에 등록한 객체들을 '빈'이라고 합니다.

---

## 💡의존성 주입(DI, Dependency Injection)에 대해 설명해주세요.

- 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아서 사용하는 것입니다.
- 이를 통해 객체 간의 결합도를 줄이고 코드의 재사용성을 높일 수 있습니다.
- 의존성 주입은 생성자 주입, 필드 주입, 세터 주입의 3가지 방법이 있습니다.
- 이 중 Spring에서 가장 권장하는 의존성 주입 방법은 생성자를 통한 주입 방법입니다.
- 그 이유는 1. 순환 참조 방지 2. 불변성 3. 테스트 용이 때문입니다.

---

## 💡스프링 빈의 라이프사이클은 어떻게 관리되는지 설명해주세요.

- 먼저 스프링 Bean의 LifeCycle은 다음과 같습니다.
- 스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료
- 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 관리합니다.
    1. 인터페이스( InitializingBean, DisposableBean )
    2. 설정 정보에 초기화 메소드, 종료 메소드 지정
    3. @PostConstruct, @PreDestroy 어노테이션 지원

---

## 💡Spring Filter와 Interceptor에 대해 설명하고, 사용 예시를 설명해주세요.

- 필터는 말 그대로 요청과 응답을 거른뒤 정제하는 역할을 합니다.
- 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리가 되는 것이고, 스프링 범위 밖에서 처리됩니다.
- Dispatcher Servlet에 요청이 전달되기 전 / 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공합니다.
    - 사용 사례 :보안 및 인증/인가 관련 작업, 모든 요청에 대한 로깅 또는 검사이미지/데이터 압축 및 문자열 인코딩 Spring과 분리되어야 하는 기능
- 인터셉터는 요청에 대한 작업 전 / 후로 가로채 요청과 응답을 참조하거나 가공하는 역할을 합니다.
- 웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작합니다.
- Dispatcher Servlet이 Controller를 호출하기 전 / 후에 인터셉터가 끼어들어 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공
    - 사용 사례 :세부적인 보안 및 인증/인가 공통 작업, API 호출에 대한 로깅 또는 검사, Controller로 넘겨주는 정보(데이터)의 가공

---

## 💡관점지향 프로그래밍(AOP, Aspect Oriented Programming)는 무엇이고, 언제 사용할 수 있을까요?

- AOP는 핵심 비즈니스 로직에 있는 공통 관심사항을 분리하여 각각을 모듈화 하는 것을 의미하며, 공통 모듈인 인증, 로깅, 트랜잭션 처리에 용이합니다.
- 핵심 비즈니스 로직에 부가 기능을 하는 모듈이 중복되어 분포되어 있을 경우 사용할 수 있습니다.
- AOP의 가장 큰 특징이자 장점은 중복 코드 제거, 재활용성의 극대화, 변화 수용의 용이성이 좋다는 점입니다.

---

## 💡서블릿(Servlet)에 대해 설명해주세요.

- 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술입니다.
- Spring MVC에서 Controller로 이용되며, 사용자의 요청을 받아 처리한 후에 결과를 반환합니다. 자바를 사용해 웹을 만들기 위해 필요한 기술

---

## 💡 서블릿의 동작 방식에 대해 설명해주세요.

- 사용자(Client)가 URL을 입력하면 HTTP Request가 Servlet Container로 전송됩니다.
- 요청 받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성합니다.
- web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다.
- 해당 서블릿에서 service메소드를 호출한 후 GET, POST여부에 따라 doGet() 또는 doPost()를 호출합니다.
- doGet() or doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse객체에 응답을 보냅니다
- 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다.

---


## 💡Spring의 싱글톤 패턴에 대해 설명해주세요.

- 스프링에서 bean 생성시 별다른 설정이 없으면 default로 싱글톤이 적용됩니다.
- 스프링은 컨테이너를 통해 직접 싱글톤 객체를 생성하고 관리하는데, 요청이 들어올 때마다 매번 객체를 생성하지 않고, 이미 만들어진 객체를 공유하기 때문에 효율적인 사용이 가능합니다.
- 이를 통해 다음과 같은 장점을 얻을 수 있습니다.
    - static 메소드나 private 생성자 등을 사용하지 않아 객체지향적 개발을 할 수 있다.
    - 테스트하기 편리하다.

---

## 💡 @Transactional에 readOnly 속성을 사용하는 이유에 대해서 설명해주세요.

- 트랜잭션 안에서 수정/삭제 작업이 아닌 ReadOnly 목적인 경우에 주로 사용하며, 영속성 컨텍스트에서 엔티티를 관리 할 필요가 없기 때문에 readOnly를 추가하는 것으로 메모리 성능을 높일 수 있고, 데이터 변경 불가능 로직임을 코드로 표시할 수 있어 가독성이 높아진다는 장점이 있습니다.
- readOnly 속성이 없는 보통의 트랜잭션은 데이터 조회 결과 엔티티가 영속성 컨텍스트에 관리되며, 이는 1차 캐싱부터 변경 감지(Dirty Checking)까지 가능하게 된다.
- 하지만, 조회시 스냅샷 인스턴스를 생성해 보관하기 때문에 메모리 사용량이 증가한다.

---

## 💡 JPA N + 1 문제와 발생하는 이유 그리고 해결하는 방법을 설명해주세요.

- N+1이란 1번의 쿼리를 날렸을 때 의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것을 의미합니다.
- 해결 방법에는 여러 방법이 있지만 가장 많이 사용되는 방법은 Fetch Join을 사용해 해결하는 방법입니다.
- N+1 문제가 발생하는 이유는 연관관계를 가진 엔티티를 조회할 때 한 쪽 테이블만 조회하고 연결된 다른 테이블은 따로 조회하기 때문인데, Fetch Join을 사용하면 미리 두 테이블을 Join하여 한 번에 모든 데이터를 가져오기 때문에 N+1문제를 애초에 막을 수 있습니다.
