# 질문 셋 1 - HTTP와 네트워크

---

1. **GET 방식 요청과 POST 방식 요청의 차이에 설명해주세요.**

`GET`은 데이터를 조회하기 위해 사용되는 HTTP 메서드로 데이터를 헤더에 추가하여 전송하는 방식입니다.

URL에 데이터가 노출되므로 개인정보를 포함해서는 안됩니다.

`POST` 는 데이터를 추가 또는 수정하기 위해 사용되는 방식으로 데이터를 HTTP 요청 바디에 추가하여 전송하는 방식입니다.

| 처리 방식 | GET 방식 | POST 방식 |
| --- | --- | --- |
| URL에 데이터 노출 여부 | O | X |
| 데이터 위치 | 헤더 | 바디 |
| 캐싱 가능 여부 | O | X |
| 멱등성 여부 | O | X |

---

1. **로그인 정보 전송시에 GET 요청을 사용하면 안되나요?**

GET 요청은 URL에 파라미터가 노출되므로 사용하면 안 됩니다.

GET 요청으로 로그인 정보를 전송하게 되면 브라우저 히스토리, 서버 로그, 캐시 등에 비밀번호 등이 저장되고 노출될 위험이 있습니다.

---

1. **URI와 URL의 관계에 대해서 설명해주실 수 있나요?**

`URI(Uniform Resource Identifier)`는 **자원을 식별하기 위한 통합 식별자**를 뜻하고, `URL(Uniform Resource Locator)` 는 **해당 자원의 위치(주소)를 나타내는 식별자**입니다.

즉, URL은 URI의 하위 개념이다.

참고로 `URN(Uniform Resource Name)` 은 자원의 위치 없이 **이름만으로 식별**하는 식별자이다.

---

1. **웹 브라우저에 [google.com](http://google.com) 입력해 접속하면 어떤 일이 일어나나요?**

- **브라우저 캐시 확인**: 먼저 브라우저는 해당 URL에 대한 캐시된 콘텐츠가 있는지 확인하고, 유효하다면 이를 그대로 사용합니다.
- **DNS 조회**: IP 주소가 캐시에 없다면, 브라우저는 로컬 DNS 캐시를 확인하고, 없을 경우 DNS 서버에 질의하여 `google.com`에 대한 IP 주소를 조회합니다. (보통 **UDP 프로토콜**이 사용)
- **TCP 연결 수립**: IP 주소가 확인되면, 브라우저는 해당 서버와의 **TCP 연결을 3-way 핸드셰이킹**을 통해 설정합니다. 만약 HTTPS를 사용하는 경우, 이후 **TLS 핸드셰이크**도 수행됩니다.
- **HTTP 요청 전송**: TCP 연결이 완료되면 브라우저는 HTTP 또는 HTTPS 요청을 서버로 보냅니다.
- **서버 응답 처리**: 서버는 요청을 처리한 후, HTML, CSS, JS, 이미지 등의 리소스를 포함한 **HTTP 응답**을 브라우저로 전송합니다.
- **브라우저 렌더링**: 브라우저는 받은 응답을 파싱하고, DOM 트리 및 렌더 트리를 구성하여 화면에 웹페이지를 렌더링합니다. 이 과정에서 JavaScript 실행, 스타일 적용, 이미지 로딩 등이 병렬로 수행됩니다.
- **캐싱 및 연결 재사용**: 응답에 따라 리소스는 브라우저에 캐시될 수 있고, TCP 연결은 HTTP/1.1의 Keep-Alive 또는 HTTP/2의 멀티플렉싱을 통해 재사용될 수 있습니다.

---

1. **(DNS 설명 잘 안 이뤄지면) DNS가 무엇인지 설명해주실 수 있나요?**

`DNS(Domain Name System)` 은 사용자가 웹사이트를 접속할 때 입력하는 도메인 이름을 컴퓨터가 이해할 수 있는 IP 주소로 변환해주는 시스템입니다.

사용자가 브라우저에 도메인을 입력하면, 브라우저는 먼저 로컬 캐시, OS 캐시 등을 확인하고, 없을 경우 DNS 서버에 질의하여 해당 도메인의 IP 주소를 조회합니다.

# 질문 셋 2 - 지속 커넥션, HTTP 버전, DB

---

1. **HTTP keep-alive란 무엇인가요?**

HTTP keep-alive는 클라이언트와 서버 간의 **TCP 연결을 재사용**할 수 있도록 해주는 기능입니다.

기본적으로 HTTP/1.0에선 요청-응답 과정이 끝나면 TCP 연결이 종료되지만, keep-alive 기능을 사용하면 한번 연결된 TCP 커넥션을 계속 사용할 수 있습니다.

---

1. **HTTP keep-alive가 사용되는 이유와 장점에 대해서 설명해주실 수 있나요?**

HTTP keep-alive를 사용하면

1. TCP 연결 수립 과정(3-way handshake)에 드는 비용을 줄일 수 있습니다.
2. TCP 연결은 서서히 전송 속도를 높이기에 새 연결보다 빠르게 전송할 수 있습니다.

---

1. **현재 주로 사용되고 있는 HTTP 버전에 대해서 알고 계시나요?**

`HTTP/1.1`는 가장 널리 사용되는 버전으로 SSL이 적용되지 않은 http 통신을 할 때 사용합니다. Keep-alive를 기본으로 사용합니다. 하지만 커넥션에서 요청을 순차적으로 처리합니다.

`HTTP/2`는 2015년부터 보편화 중인 버전으로 하나의 TCP 커넥션에서 동시에 여러 요청/응답을 처리 가능합니다. 헤더 압축을 통해 오버헤드를 감소시켰습니다.

`HTTP/3`는 TCP가 아닌 UDP를 사용하는 버전으로 지연시간을 줄이고 성능이 향상되었습니다. QUIC 프로토콜을 사용해 연결 설정과 패킷 손실 회복에 대응합니다.

---

1. **HTTP/1.1과 비교해서 HTTP/2나 HTTP/3에서 개선된 사항을 아시는 대로 설명해주실 수 있나요?**

HTTP/2

| 항목 | HTTP/1.1 | HTTP/2 (개선 내용) |
| --- | --- | --- |
| **요청 처리** | 순차적으로 하나씩 처리 → 헤드-오브-라인 블로킹 발생 | **멀티플렉싱 지원**: 하나의 커넥션으로 동시에 여러 요청/응답 처리 |
| **헤더** | 매 요청마다 중복된 헤더 전송 | **헤더 압축 (HPACK)** 적용 → 전송량 감소 |
- 멀티플렉싱과 keep-alive의 차이
    - keep-alive: 하나의 TCP 커넥션을 여러 요청에 재사용
    - 멀티플렉싱: 하나의 TCP 커넥션에서 요청을 **동시에** 처리

HTTP/3

| **항목** | HTTP/2 (기반: TCP) | HTTP/3 (기반: **QUIC**, UDP) |
| --- | --- | --- |
| **전송 계층** | TCP + TLS (연결과 보안 따로) | **QUIC**: TLS 포함한 단일 계층, 빠른 연결 |
| **지연 시간** | TCP 핸드셰이크 + TLS 핸드셰이크로 초기 연결 느림 | **0-RTT 연결 가능** → 첫 연결 이후 빠른 재접속 |

---

1. **JPA를 사용할 때 서버와 DBMS 사이의 통신에 대해 얘기해볼께요. 서버와 DBMS 사이에도 TCP 통신으로 데이터를 교환하는데 DB에 접속할 때마다 커넥션을 만드나요? 어떻게 작동하는지 알고 계시나요?**

`커넥션 풀`을 사용해서 일정 개수의 DB 커넥션을 **미리 생성해서 풀에 보관**해두고, 클라이언트 요청이 들어올 때마다 **풀에서 커넥션을 꺼내 사용하고 다시 반납**합니다. 이렇게 하면 매번 TCP 커넥션을 만들 필요 없이 빠르게 DB에 접근할 수 있습니다.

---

1. **DB의 연산량이 감당할 수 없을 정도로 많아지면 어떻게 개선해보시겠어요?**
    1. **DB 서버의 스케일업** : CPU, RAM, 디스크 성능을 높여 서버 성능 향상
    2. **읽기 전용 복제본 (Read Replica) 구성** : 읽기 쿼리 부하를 복제본으로 분산, 조회 API → 복제본 사용 / 쓰기 API → 마스터 DB 사용
    3. **캐싱 도입** : Redis, Memcached 등의 인메모리 데이터베이스를 사용해 캐싱
    4. **파티셔닝, 샤딩**

# 질문 셋 3 - 지속 커넥션, TCP, 세션과 토큰

---

1. **HTTP keep-alive란 무엇인가요?**

HTTP keep-alive는 클라이언트와 서버 간의 **TCP 연결을 재사용**할 수 있도록 해주는 기능입니다.

기본적으로 HTTP/1.0에선 요청-응답 과정이 끝나면 TCP 연결이 종료되지만, keep-alive 기능을 사용하면 한번 연결된 TCP 커넥션을 계속 사용할 수 있습니다.

---

1. **HTTP keep-alive가 사용되는 이유와 장점에 대해 설명해주실 수 있나요?**

HTTP keep-alive를 사용하면

1. TCP 연결 수립 과정(3-way handshake)에 드는 비용을 줄일 수 있습니다.
2. TCP 연결은 서서히 전송 속도를 높이기에 새 연결보다 빠르게 전송할 수 있습니다.

---

1. **TCP 통신에서 슬라이딩 윈도우 기법을 이용합니다. 슬라이딩 윈도우 기법이 어떤 것이고 사용되는 이유가 무엇인지 설명해주실 수 있나요? (아니면 OSI 7 계층 중 어떤 계층에서 일어나는지)**

`슬라이딩 윈도우`는 TCP에서 데이터를 연속적으로 전송하기 위해 사용하는 흐름 제어 기업입니다.

송신자 측은 **윈도우에 해당하는 여러 개의 패킷을 한 번에 전송**하고, 수신자로부터 **확인 응답(ACK)를 받으면 다음 전송 범위로 윈도우를 밀어 올립니다**.

이를 통해 패킷 하나씩 보낼 때보다 전송 속도를 향상시키고, **윈도우의 크기에 따라 전송량을 제어**하여 **흐름 제어**를 할 수 있습니다. 또한 **윈도우 크기를 동적으로 조절**하여 **혼잡 제어**를 합니다.

이는 OSI 7 계층 중 전송 계층(4 계층)에서 동작합니다. 

---

1. **TCP 연결의 종료 과정에 대해서 알고 계시나요? TCP 연결 종료 과정에 대한 간단한 설명과 `TIME_WAIT` 상태를 연관지어 설명해주시겠어요?**

TCP 연결을 종료할 때는 **4-way handshake 절차**를 따릅니다:

1. **클라이언트 → 서버: FIN 전송**
2. **서버 → 클라이언트: ACK 응답**
3. **서버 → 클라이언트: FIN 전송**
4. **클라이언트 → 서버: ACK 응답**

마지막으로 ACK를 보낸 쪽(보통 클라이언트)이 `TIME_WAIT` 상태로 대기합니다. 이는 **지연된 패킷이 네트워크에 남아 나중에 도착해 새로운 연결에 영향을 주지 않게** 하는 게 목적입니다. 또한 **마지막 ACK가 전송 중 손실될 경우 FIN 재전송 역할**도 합니다.

---

1. **이번엔 인증 방법에 대해 얘기해볼께요. 세션 기반 인증과 토큰 기반 인증의 차이에 대해 얘기해주세요.**

- **세션 기반 인증**은 로그인 정보를 서버가 **세션으로 저장**하고, 클라이언트는 세션 ID를 **쿠키로 보냅니다.**
- **토큰 기반 인증**은 로그인 시 서버가 **JWT 같은 토큰을 발급**하고, 클라이언트가 이를 **헤더에 포함해 전달**합니다. 서버는 상태를 저장하지 않습니다.

| 항목 | 세션 기반 인증 | 토큰 기반 인증 (JWT 등) |
| --- | --- | --- |
| **상태 관리** | 서버가 세션 저장 (Stateful) | 서버 상태 저장 안 함 (Stateless) |
| **저장 위치** | 서버 메모리, Redis 등 | 클라이언트 (로컬스토리지 등) |
| **전송 방식** | 쿠키 | Authorization 헤더 |
| **확장성** | 낮음 (서버 종속) | 높음 (서버 간 공유 불필요) |
| **보안 이슈** | 세션 탈취, CSRF | 토큰 탈취, 만료 관리 필요 |
| **로그아웃 처리** | 세션 삭제로 즉시 반영 | 토큰 만료 전까지 유효 |

---

1. **프로젝트에서 MSA 구조를 채택해서 스프링 부트 서버가 여러 개 있다고 생각해볼게요. 어떤 인증 방법이 적합할까요?**

토큰 기반 인증이 상대적으로 적합합니다.

- **Stateless**: 각 서비스가 **서버에 인증 상태를 저장하지 않아도 되므로**, 수평 확장에 적합
- **서비스 간 인증 공유**: JWT 같은 토큰은 자체적으로 **사용자 정보를 담고 있으므로**, 모든 마이크로서비스에서 **공통된 방식으로 검증** 가능
- **게이트웨이에서 인증 처리 가능**: API Gateway에서 토큰을 검증하고, 내부 서비스에는 **인증된 사용자 정보만 전달** 가능

---

1. **세션 기반 인증 방법을 사용하고 싶다면 어떤 구조로 설계하시겠어요?**

제가 생각한 답변: Redis 등의 데이터베이스를 사용해 세션 저장소를 중앙화해서, 모든 마이크로서비스가 동일한 세션 정보를 참조할 수 있도록 구성합니다.

그외, 세션 클러스터링에 이런 방식이 있다고 합니다.

| 방식 | 설명 | 장점 | 단점 |
| --- | --- | --- | --- |
| **공유 세션 저장소 사용** | Redis, DB 등 외부 저장소에 세션 저장 | 가장 많이 사용됨, 확장성 좋음 | 외부 저장소 구축 필요 |
| **서버 간 세션 동기화** | 각 서버가 다른 서버와 세션 상태를 동기화 | 상태 유지 가능 | 구현 복잡, 느릴 수 있음 |
| **Sticky Session** | 같은 사용자는 항상 같은 서버로 라우팅 | 간단 | 서버 장애 시 문제 발생 |

# 예비 질문

---

1. **스프링 부트의 임베디드 톰캣 서버는 여러 요청을 어떻게 동시에 처리하나요? (요청마다 스레드를 생성하나요?)**

톰캣은 요청마다 스레드를 생성하는 것이 아니라, 미리 만들어 둔 스레드 풀에서 스레드를 할당해 요청을 처리합니다.

[[Spring] 스프링 부트, 요청이 몰리면 어떻게 될까?](https://constructionsite.tistory.com/70)

---

1. **공인(public) IP와 사설(private) IP의 차이에 대해 설명해주세요.**

`공인 IP`는 IP(인터넷 서비스 공급자)가 제공하는 IP 주소이며, 외부에 공개되어 있는 IP 주소입니다.

`사설 IP`는 일반 가정이나 회사 내 등에 할당된 네트워크 IP 주소이며, 라우터에 의해 로컬 네트워크 상 장치에 할당됩니다.

---

1. **DHCP 프로토콜의 역할에 대해 알고 계시나요?**

`DHCP`는 IP 주소와 네트워크 설정 정보를 자동으로 할당해주는 프로토콜입니다.

---

1. **OSI 7 레이어라 불리는 네트워크 계층 구조에 대해 설명해보세요. 각 계층에서 어떤 역할을 하는지 예시를 들어줄 수 있나요?**

OSI 7계층은 네트워크 통신을 단계적으로 나눈 모델로, 각 계층이 서로 다른 역할을 맡아서 통신을 효율적으로 처리할 수 있게 도와줍니다. 위에서부터 아래로 설명드리면 다음과 같습니다:

**응용 계층 (Application)**: 사용자에게 가장 가까운 계층으로, 웹 브라우저, 이메일 등이 여기에 해당합니다.

**표현 계층 (Presentation)**: 데이터의 인코딩, 압축, 암호화 같은 작업을 담당합니다.

**세션 계층 (Session)**: 세션을 생성하고 관리해서 양쪽의 통신 상태를 유지시킵니다.

**전송 계층 (Transport)**: 데이터의 신뢰성 보장을 담당하고, TCP/UDP가 여기에 포함됩니다.

**네트워크 계층 (Network)**: IP 주소를 기반으로 라우팅을 담당합니다.

**데이터 링크 계층 (Data Link)**: MAC 주소를 이용해 물리적 네트워크 내에서 통신합니다.

**물리 계층 (Physical)**: 전기적 신호, 케이블, 허브 등 물리적 연결 자체를 의미합니다.

---

1. **HTTP 요청을 보낼 때 전송 계층과 네트워크 계층, 데이터 링크 계층에서 각각 무슨 일이 일어나는지 설명해주실 수 있나요?**

| 계층 | 역할 |
| --- | --- |
| **전송 계층 (TCP)** | HTTP 데이터를 **TCP 세그먼트로 분할하고**, **송신 측 포트 번호**를 붙여 **신뢰성 있는 전송**을 보장 (예: 순서 보장, 재전송 등) |
| **네트워크 계층 (IP)** | TCP 세그먼트를 **IP 패킷으로 캡슐화**하고, **송수신 IP 주소**를 붙여 목적지까지 전달할 **논리적 경로**를 설정 |
| **데이터 링크 계층 (Ethernet)** | IP 패킷을 **프레임으로 캡슐화**하고, **MAC 주소를 붙여** 로컬 네트워크 내에서 실제 **물리적 전송**을 담당 |