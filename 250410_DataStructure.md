## 1. Stack과 Queue의 차이점을 설명해주세요.

- Stack
    - 후입선출(LIFO) 구조, 가장 나중에 들어온 데이터가 가장 먼저 나간다.
- Queue
    - 선입선출(FIFO) 구조, 가장 먼저 들어온 데이터가 가장 먼저 나간다.

### 1-1. 우선순위 큐(PriorityQueue)에 대해 설명해주세요.

- 우선순위 큐는 요소들이 우선순위에 따라 처리되는 큐이다.
- 일반적인 큐는 FIFO(선입선출) 방식으로 작동하지만, 우선순위 큐는 우선순위가 높은 요소가 먼저 나오는 구조다.
- 보통 Heap(최소/최대 힙) 자료구조를 이용해 구현한다.
  worst case라도 시간 복잡도 O(logN)을 보장하기 때문에 완전 이진 트리 형태의 힙을 이용해 구현한다.

## 2. List와 Set의 차이점에 대해 설명해주세요.

- List
    - 입력 순서가 보장된다. 인덱스를 통해 특정 위치의 요소에 접근할 수 있다.
    - 중복을 허용한다.
    - 삽입, 삭제에 O(n)의 시간 복잡도를 가진다.
- Set
    - 순서가 보장되지 않고(LinkedHashSet과 같이 순서를 유지하는 Set도 존재), 중복을 허용하지 않는다.
    - 일반적으로 HashSet의 경우 삽입, 삭제에 평균 O(1)의 시간 복잡도를 가진다.
    - TreeSet과 같이 정렬된 Set은 O(log n)의 시간 복잡도를 가진다.

## 3. Array

### 3-1. Array와 ArrayList의 차이점에 대해 설명해주세요.

- Array
    - 배열은 선언 시 크기가 결정된다. 크기를 변경하려면 새로운 배열을 생성하고 기존 요소를 복사해야 한다.
- ArrayList
    - 필요에 따라 내부 배열의 크기를 자동으로 늘리거나 줄일 수 있는 동적 배열이다.
    - 요소의 개수가 증가하면 더 큰 배열을 할당하고 기존 데이터를 복사한다.

### 3-1. Array과 LinkedList의 접근, 삽입, 삭제 시간 복잡도에 대해 설명해주세요.

- Array
    - 접근할 때 인덱스를 통해 직접 접근할 수 있어 O(1)의 시간 복잡도를 가진다.
    - 삽입, 삭제할 때는 해당 지점 이후의 모든 요소들을 이동시켜야 하므로 O(n)의 시간 복잡도를 가진다.
- LinkedList
    - 접근할 때 원하는 인덱스까지 순차적으로 찾아야 하므로 O(n)의 시간 복잡도를 가진다.
    - 삽입, 삭제할 때는 해당 위치의 포인터(주소)만 변경하면 되기 때문에 O(1)의 시간 복잡도를 가진다.

### 3-2. 배열 요소에 접근할 때 O(1)의 시간이 걸리는 이유를 설명해주세요.

- 배열은 연속된 메모리 공간에 저장되고, 각 요소는 고정 크기를 가진다.
- 원하는 인덱스 i에 접근할 때, 0번째 인덱스 주소(base-address) + (i * 요소의 크기)로 인덱스 값의 주소를 얻을 수 있다. (Random Access)
- 위 계산은 배열의 크기와 상관없이 항상 동일한 시간 내에 수행될 수 있다.

## 4. HashMap에 대해 설명해주세요.

- Key-Value 쌍으로 데이터를 저장하는 자료구조 (해시 테이블)
- Key를 해싱하여 배열의 인덱스로 변환해 값을 저장
- 순서를 보장하지 않는다.
- 접근, 삽입, 삭제의 평균 시간 복잡도 O(1)

## 5. 비선형 구조에 대해 설명해주세요.

- 하나의 요소 뒤에 여러 개의 요소가 존재할 수 있는 형태를 말한다.
- 데이터 간 관계가 일대다(1:N) 혹은 다대다(N:N)로 구성된 구조를 말한다.
- 대표적으로 트리와 그래프가 있다.

## 6. 이진 트리에 대해 설명해주세요.

- 각 노드가 최대 2개의 자식 노드를 가지는 트리 구조를 말한다.
- 트리의 가장 간단한 형태로, 다양한 트리 구조(이진 탐색 트리, AVL 트리, 레드-블랙 트리 등)의 기반이 된다.

### 6-1. 이진 탐색 트리(BST)에 대해 설명해주세요.

- 정렬된 트리 구조이다.
- 각 노드의 왼쪽 서브 트리는 해당 노드보다 작은 값, 오른쪽 서브 트리는 해당 노드보다 큰 값을 가진 노드들로 이루어져 있다.
- 가장 왼쪽에 있는 노드는 최솟값, 가장 오른쪽에 있는 노드는 최댓값을 가진다.

### 6-2. Heap에 대해 설명해주세요.

- 여러 개의 값 중에서 최댓값 혹은 최솟값을 빠르게 찾기 위해 만든 완전 이진 트리다.
    - 완전 이진 트리는 트리의 위부터 아래, 왼쪽부터 오른쪽의 순서로 빠짐없이 가득 차있는 이진 트리를 말한다.
- 중복 값이 허용된다.
- 최대 힙은 부모 노드의 키 값이 자식 노드보다 크거나 같은 완전 이진 트리다.
- 최소 힙은 부모 노드의 키 값이 자식 노드보다 작거나 같은 완전 이진 트리다.

### 6-3. 최소 힙에 노드(20)가 삽입되었을 때 동작하는 과정을 설명해주세요.

```
            14
          /    \
        22      19
       /  \    /  \
     25   29  21  23
    / \   /
   32 30 31
```
```
            14
          /    \
        20      19
       /  \    /  \
     25   22  21  23
    / \   / \
   32 30 31 29
```

1. 트리의 가장 마지막 위치에 노드(20)를 삽입한다.
2. 부모 노드와 값을 비교해, 부모가 더 크다면 두 노드를 교환한다.
3. 루트 노드에 도달하거나, 부모가 더 작을 때까지 2번 과정을 반복한다.
