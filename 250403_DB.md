## 1. SQL에 대해서 설명해주세요.

- 관계형 데이터베이스 관리 시스템(RDBMS)에서 데이터를 관리하고 조작하기 위한 프로그래밍 언어이다.

### 1-1. DDL, DML, DCL에 대해 설명해주세요.

- DDL(Data Definition Language)
    - 데이터베이스 구조를 정의, 수정, 삭제할 때 사용한다.
    - CREATE, ALTER, DROP, TRUNCATE
- DML(Data Manipulation Language)
    - 데이터베이스에 저장된 데이터를 관리하고 조작할 때 사용한다.
    - SELECT, INSERT, UPDATE, DELETE
- DCL(Data Control Language)
    - 데이터베이스 사용 권한을 제어할 때 사용한다.
    - GRANT, REVOKE

### 1-2. JOIN과 UNION의 차이에 대해 설명해주세요.

- JOIN
    - 두 개 이상의 테이블을 가로 방향으로 결합 (열 결합)
    - 두 테이블 간의 관련 있는 열을 기준으로 결합한다.
- UNION
    - 두 개 이상의 SELECT 문의 결과를 세로 방향으로 결합하여 하나의 집합으로 표시 (행 결합)
    - 각 테이블의 열 수와 데이터 유형이 같아야 한다.

## 2. 정규화가 무엇인지, 그리고 필요한 이유에 대해 설명해주세요.

- 관계형 데이터베이스를 설계할 때, 데이터 중복을 최소화하고 데이터 무결성을 향상시키기 위해, 테이블을 체계적으로 분해하고 구조화하는 과정을 의미한다.
- 데이터 중복 최소화, 데이터 무결성 향상(이상 현상 방지), 데이터 구조의 안정성 및 유연성 향상

### 2-1. 정규화 과정에 대해 설명해주세요.

- 제1정규형(1NF)
    - 모든 속성(열)은 원자값을 가져야 한다.
    - 하나의 셀에는 하나의 값만 들어가야 하며, 여러 개의 값을 묶어서 표현하거나 반복되는 그룹이 없어야 한다.
- 제2정규형(2NF)
    - 1NF를 만족하면서 부분 함수 종속(기본키를 구성하는 속성들 중 일부에만 종속되는 경우)을 제거한다.
    - 기본 키에 속하지 않은 모든 속성이 기본 키에 대해 완전 함수 종속(기본키를 구성하는 모든 속성들에 종속되는 경우)을 만족해야 한다.
- 제3정규형(3NF)
    - 2NF를 만족하면서 이행 함수 종속을 제거한다.
    - 이행 함수 종속은 A → B, B → C 일 때, A → C를 만족하는 관계를 말한다.

### 2-2. 정규화를 끝까지 하는 게 좋을까요?

- 정규화를 너무 많이 하면 테이블이 잘게 쪼개져서 조회 시 조인이 많이 발생하고 성능이 떨어질 수 있다.
- 보통 3정규형까지만 하고, 필요한 경우 반정규화를 통해 성능을 개선한다.

### 2-3. 반정규화에 대해 설명해주세요.

- 성능 향상을 위해 의도적으로 정규화 원칙에 위배하여 데이터 중복을 허용하고 조인을 줄이는 성능 향상 방법이다.
- 정규화가 데이터 중복을 최소화하고 데이터 무결성을 높이기 위해 테이블을 잘게 분리하는 과정이라면, 반정규화는 시스템의 조회(읽기) 성능을 높이기 위해 어느 정도의 데이터 중복을 감수하고 테이블 구조를 변경하는 과정이다.

## 3. ORM에 대해 설명해주세요.

- ORM(Object Relational Mapping)은 객체 지향 프로그래밍 언어의 객체와 관계형 데이터베이스의 테이블 사이를 자동으로 매핑해주는 기술이다. 객체와 테이블을 매핑하여 SQL 쿼리를 직접 작성하지 않고도 객체를 통해 데이터베이스를 조작할 수 있게 해준다.

### 3-1. JPA에서 영속성 컨텍스트란 무엇인가요?

- 엔티티를 영구 저장하는 환경을 의미한다.
- 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상 데이터베이스(캐시) 역할을 한다.
- 엔티티의 생명 주기를 관리하며, 주로 EntitiyManager를 통해 접근한다. 이를 통해 엔티티를 저장, 수정, 삭제, 조회할 때 엔티티를 영속성 컨텍스트에 등록하고 관리하게 된다.

### 3-2. N + 1 문제에 대해 설명하고, 이를 해결할 수 있는 방법을 설명해주세요.

- 연관된 엔티티를 조회할 때 발생하는 성능 문제를 말한다.
- 한 번의 조회로 1개의 메인 엔티티를 가져오고, 그와 연관된 N개의 엔티티를 개별적으로 조회하는 문제가 발생한다. 즉, 1 + N번의 쿼리가 실행되는 비효율적인 상황을 의미한다.
- JPA Repository의 메서드 호출 시(findAll(), findById() 등의 조회 메서드) 발생한다.
- 해결 방법
    - Fetch Join
        - JOIN FETCH를 사용하여 연관된 엔티티까지 한 번에 조회한다.
        - 한 번의 쿼리로 연관 엔티티까지 가져와 성능이 향상된다. (inner join)
            - inner join이 outer join보다 성능 최적화에 유리하다.
        - 중복 데이터가 생길 수 있고, Pageable(페이징) 기능, 별칭을 사용할 수 없다.
        - 1 : N 관계가 2개 이상인 엔티티를 조회할 때 MultipleBagFetchException이 발생한다.

        ```java
        @Query("SELECT p FROM Post p JOIN FETCH p.writer")
        List<Post> findAllWithWriter();
        ```

    - @EntityGraph
        - 복잡한 JPQL을 줄이고 Fetch Join 효과를 낼 수 있다. (outer join)
        - 중복 데이터가 생길 수 있다. (카테시안 곱)
          Fetch Join과 EntityGraph는 DISTINCT나 필드 타입을 Set(LinkedHashSet)으로 선언하여 중복을 제거할 수 있다.

      > 카테시안 곱
      두 테이블 사이에 유효 join 조건을 적지 않았을 때 해당 테이블에 대한 모든 데이터를 전부 결합하여 테이블에 존재하는 행 갯수를 곱한만큼의 결과 값이 반환되는 것
      >

        ```java
        @EntityGraph(attributePaths = {"writer"})
        List<Post> findAll();
        ```

    - Batch Size 설정
        - 한 번에  N개의 엔티티를 미리 로드하여 쿼리 수를 줄이고 성능을 향상시키기 위해 사용한다.
        - batchSize가 100이고 게시글이 500개라면, 작성자 정보를 가져오기 위해 5번의 IN 절 쿼리가 실행된다.
        - 페이징 처리가 가능하고 1 : N 관계가 여러 개이더라도 사용할 수 있다.
        - 데이터베이스 부하와 메모리 사용량이 증가할 수 있다.

        ```java
        @BatchSize(size = 100)
        
        spring:
          jpa:
            properties:
              hibernate:
                default_batch_fetch_size: 100
        ```


### 3-3. 지연 로딩과 즉시 로딩의 차이점은 무엇인가요?

- Lazy
    - 지연 로딩된 프록시 객체를 실제 사용할 때, 연관된 데이터 접근 시점에 추가 쿼리가 발생한다.
    - 초기 로딩 시 불필요한 데이터를 가져오지 않으므로 성능이 향상된다.
    - 메모리 사용을 줄일 수 있다.
- Eager
    - 즉시 로딩으로 인해 연관 엔티티를 바로 조회, 각각의 엔티티마다 추가 쿼리가 발생한다.
    - 불필요한 데이터를 한꺼번에 로딩하여 메모리 낭비가 발생할 수 있다.
    - 데이터가 많을 경우 초기 로딩 속도 저하를 유발할 수 있다.

## 4. 프로젝트에 적용해본 데이터베이스가 있다면 무엇인가요? 그리고 해당 데이터베이스를 선택하신 이유는 무엇인가요?
