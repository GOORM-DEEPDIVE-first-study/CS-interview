# 운영체제 면접 질문 정리

---

## 1. 멀티스레드와 멀티프로세스의 차이를 설명해주세요.

- **멀티스레딩**: 하나의 프로세스 내에서 여러 개의 스레드가 자원을 공유하며 실행.
  - **장점**: 문맥 전환 비용이 낮고 자원 공유가 용이.
  - **단점**: 동기화 문제로 경쟁 상태와 데드락 발생 가능.

- **멀티프로세싱**: 여러 개의 프로세스가 독립적인 메모리 공간을 가지며 실행.
  - **장점**: 안정성이 높고 독립적인 실행이 가능.
  - **단점**: IPC 비용이 크고 생성 오버헤드가 큼.

---

## 2. 스케줄링 알고리즘의 종류와 각각의 특징을 설명해주세요.

- **FCFS (First-Come, First-Served)**: 먼저 도착한 프로세스를 먼저 실행.
  - **단점**: Convoy Effect(긴 프로세스로 인해 짧은 프로세스가 지연되는 현상) 발생.
  
- **SJF (Shortest Job First)**: 실행 시간이 짧은 프로세스를 우선 실행.
  - **단점**: 긴 프로세스가 계속 대기하는 기아(Starvation) 현상 발생.
  
- **RR (Round Robin)**: 일정한 시간마다 프로세스를 교체하여 실행.
  - **장점**: 선점형 스케줄링으로 응답 시간이 일정.
  - **단점**: 컨텍스트 스위칭 오버헤드 발생.
  
- **Priority Scheduling**: 우선순위가 높은 프로세스를 먼저 실행.
  - **단점**: 우선순위가 낮은 프로세스가 무한정 대기하는 기아 현상 발생. → Aging 기법 사용.
  
- **MQ (Multi-Level Queue) & MFQ (Multi-Level Feedback Queue)**: 프로세스를 우선순위에 따른 여러 개의 큐로 나누고, 규칙에 따라 다른 큐로 이동(MFQ)시킴.

---

## 3. MFQ에 따르면, 커널 프로세스가 사용자 프로세스보다 우선순위가 낮아질 수도 있나요?

- **답변**: 
  - X. 운영체제는 커널 모드와 유저 모드를 구분한다. 
  - 사용자 프로세스의 정상적인 동작을 위해, 자원 관리 역할을 하는 커널 프로세스의 우선순위가 더 높다.

---

## 4. 데드락이 발생하는 조건을 설명해주세요.

1. **상호 배제**: 한 번에 하나의 프로세스만 자원을 사용할 수 있음.
2. **점유 및 대기**: 자원을 점유한 상태에서 추가 자원을 요청하며 대기.
3. **비선점**: 할당된 자원을 강제로 회수할 수 없음.
4. **순환 대기**: 프로세스들이 원형으로 자원을 대기.

---

## 5. 데드락을 해결하는 방법에 대해 설명해주세요.

- **예방(Prevention)**: 네 가지 조건 중 하나를 제거 (예: 점유 및 대기를 방지하기 위해 모든 자원을 한 번에 할당).
- **회피(Avoidance)**: 은행가 알고리즘을 이용하여 안전한 상태에서만 자원을 할당.
- **탐지(Detection) 및 복구(Recovery)**: 주기적으로 데드락을 감지하고, 우선순위가 낮은 프로세스를 종료하거나 자원을 회수하여 해결.

---

## 6. 은행가 알고리즘 원리에 대해 설명해주세요.

- **답변**: 은행가 알고리즘은 **안전 상태**일 때만 자원을 할당한다.  
  - **안전 상태**: 기대 자원 > 가용 자원일 때를 의미.
  - **기대 자원**: 시스템 내 사용 가능한 자원의 수.
  - **가용 자원**: 프로세스가 앞으로 필요한 자원의 수.

---

## 7. 탐지 기법에서 데드락을 탐지하는 방법에 대해 설명해주세요.

1. **자원 할당 그래프**: 프로세스가 어떤 자원을 사용 중이고, 어떤 자원을 기다리는지를 유향 그래프로 표현한 것.
2. **타임아웃**: 일정 시간 작업이 진행되지 않으면 데드락으로 판단.

- **자원 할당 그래프 갱신 방법**:
  - 변화가 있을 때마다 갱신 → 오버헤드가 크다.
  - 주기적으로 갱신 → 오버헤드는 감소하지만 탐지가 늦어질 수 있음.

---

## 8. 가상 메모리에 대해 설명해주세요.

- **답변**: 가상 메모리는 물리 메모리보다 큰 주소 공간을 사용할 수 있도록 하는 기술로, 필요할 때만 데이터를 메모리에 적재하는 방식입니다.

---

## 9. 가상 메모리 관리 기법에 대해 설명해주세요.

- **페이징(Paging)**: 메모리를 고정된 크기의 블록으로 나누어 관리. 내부 단편화가 발생하고 페이지 테이블 관리에 추가적인 메모리 오버헤드 발생.
- **세그멘테이션(Segmentation)**: 논리적인 단위(코드, 데이터, 스택 등)로 메모리를 나누는 방식. 외부 단편화가 발생하지만 논리적 단위에 맞게 메모리를 효율적으로 할당할 수 있음.

---

## 10. 페이지 교체 알고리즘의 종류를 설명해주세요.

- **FIFO (First-In, First-Out)**: 가장 먼저 들어온 페이지를 교체. 페이지 폴트가 증가할 수 있음.
- **Optimal**: 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식. 현실적으로 구현 불가능.
- **LRU (Least Recently Used)**: 가장 오랫동안 사용되지 않은 페이지를 교체. 접근 시간이나 참조 비트를 유지하기 위한 메모리 공간이 낭비됨.
- **LFU (Least Frequently Used)**: 사용 빈도가 가장 적은 페이지를 교체. 페이지 접근 빈도를 기록하기 위한 메모리가 낭비됨.
- **NUR (Not Recently Used)**: 최근에 미사용한 페이지를 교체. 참조 비트와 변경 비트만 기록하여 메모리 효율성을 높임.
  - 초기 (0,0) → 참조 (1,0) → 변경 (1,1)
  - 교체 우선순위: (0,0) → (0,1) → (1,0) → (1,1)

---

