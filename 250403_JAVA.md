## 1차 질문
`Q. String과 StringBuilder 그리고 StringBuffer의 각각 차이에 대해 설명해주세요.`

A. 가장 기본적인 차이는 String은 불변 객체, StringBuffer은 가변 객체입니다. String은 문자열을 대표하는 것으로 문자열 조작에 유용하지만 문자열이 변경될 때마다 새로운 객체가 생성되어 메모리를 차지하게 됩니다. 반면 StringBuffer와 StringBuilder는 가변적이어서 문자열 연산 시 새로운 객체를 생성하지 않고 기존 객체를 변경하여 메모리를 효율적으로 사용합니다.

StringBuffer와 StringBuilder의 차이점은 동기화 지원 여부입니다.

`Q. String은 불변 객체인데 이건 무엇인가요?`

A. 불변 객체는 객체가 생성된 후 그 상태를 변경할 수 없는 객체를 의미합니다. 예로 String의 경우 한번 생성하면 그 값을 변경할 수 없습니다. 만약 내용을 변경하려면 새로운 객체를 생성해야 합니다.

눈으로 보기엔 같은 변수에 다른 값을 덮어쓰는 것처럼 보이지만, 실제로는 새로운 메모리 공간에 객체가 생성되고 변수가 이 새로운 객체를 참조하게 됩니다.

(+ 이 전에 생성된 객체는 더 이상 참조되지 않아 GC의 대상이 됩니다. 이러한 특성 때문에 문자열 연산이 많은 경우 메모리 효율성이 떨어질 수 있습니다)

`Q. String 객체에서 (더하기) 연산을 진행하면 이는 어떻게 처리되나요?`

A. 기존 객체를 변경할 수 없으므로, 매 연산마다 새로운 String 객체가 생성되어 메모리에 할당됩니다.

반복문 등을 통해 String 연산을 빈번하게 발생하면 그 만큼 새로운 객체가 생성되어 메모리를 많이 차지하며 성능이 저하될 수 있습니다.

`Q. String을 쓰는 것보다 StringBuilder나 StringBuffer를 쓰는 게 더 좋지않나요?`

A. 반드시 그렇지는 않습니다. String은 불변성 때문에 문자열 값이 안전하게 보호되고, 여러 스레드에서 동시 접근해도 값이 변경될 우려가 없습니다. 또한 문자열 연산이 적은 경우 StringBuilder나 StringBuffer를 사용하는 것이 더 불필요한 객체 생성일 수 있습니다.

`Q. 마지막으로 단일 쓰레드 환경에서는 어떤 것을 사용하는 것이 가장 성능이 좋나요? 그 이유는?`

A. 단일 쓰레드 환경에서는 StringBuilder를 사용하는 것이 가장 성능이 좋습니다. 그 이유는 StringBuffer는 동기화를 지원하기 때문에 불필요한 동기화 작업으로 인한 오버헤드가 발생하기 때문입니다. String은 불변 객체이므로 문자열 연산 시 새로운 객체가 생성되므로 메모리 낭비가 발생합니다.

반면 StringBuilder는 동기화를 지원하지 않아 StringBuffer보다 빠르고, 가변 객체이므로 String보다 메모리를 효율적으로 사용할 수 있습니다. 따라 단일 쓰레드 환경에서 문자열 연산이 필요할 경우 StringBuilder를 사용하는 것이 가장 효율적입니다.



`Q. 정적(static)이란 무엇인가요?`

A. 정적은 클래스 멤버라고 하며, 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스 별로 관리됩니다. static 키워드를 통해 생성된 정적 멤버들은 PermGen 또는 Metaspace에 저장되며 저장된 메모리는 모든 객체가 공유하며 하나의 멤버를 어디서든지 참조할 수 있는 장점이 있습니다.
그러나, GC의 관리 영역 밖에 존재하므로 프로그램 종료시까지 메모리가 할당된 채로 존재하므로 너무 남발한다면 시스템 성능에 악영향을 줄 수 있습니다.


---
## 2차 질문

`Q. 원시타입(int, long, float)과 참조타입(reference type)의 차이에 대해 설명해주세요`

A. 원시타입과 참조타입의 가장 큰 차이는 저장 위치, 메모리 크기, null 여부, 기본값에서 차이가 있습니다. 

우선 원시타입은 Stack에 저장되며, 각각 정해진 크기가 있습니다. 또한 null을 가질 수 없으며, 각각 기본값을 가지고 있습니다. 

반대로 참조타입은 Heap 메모리에 실제 객체가 저장되며, 객체의 크기에 따라 가변적입니다. null을 가질 수 있으며, 기본값이 null입니다.

`Q. 원시타입은 Stack에 참조타입은 Heap 메모리에 저장된다고 했는데 이러한 차이는 어떤 결과를 가져오나요?`

A. 원시타입은 Stack 메모리에 직접 접근하여 더 빠르며, ‘=’ 연산을 통한 복사 과정에서 값이 완전히 복사됩니다. 반대로 참조타입은 Stack 메모리에서 Heap 순서로 접근하여 상대적으로 느리고, 주소값만 복사합니다.

`Q. String은 원시 타입인가요? 참조 타입인가요?`

A. String은 참조 타입입니다. 원시 타입은 int, long, boolean 등과 같이 Stack 메모리에 값이 직접 저장되는 데이터 타입을 의미하는데, String은 객체이므로 Heap 메모리에 실제 값이 저장되고 Stack에는 이 객체의 주소값이 저장되는 참조 타입입니다.

`Q. String은 참조타입인데 왜 (new 연산자) 없이 생성이 가능한가요?`

A. String은 Java에서 가장 많이 사용되는 데이터 타입이기 때문에 Java는 개발자의 편의성을 위해 String에 한해 특별히 리터럴 방식의 생성을 지원합니다. 이때 생성된 문자열은 String Pool이라는 특별한 메모리 영역에서 관리되며, 동일한 문자열이 이미 Pool에 존재한다면 새로운 객체를 생성하지 않고 기존 객체를 재사용하여 메모리를 효율적으로 사용할 수 있습니다.

`Q. 마지막으로 ==(동등 연산자)와 equals(이퀄스)는 원시타입과 참조타입 각각 어떻게 작동하나요?`

A. 원시 타입의 경우 동등 연산자를 사용하면 값 자체를 비교합니다.

반면 참조 타입의 경우 동등 연산자는 객체의 주소값을 비교하고, 이퀄스는 객체의 내용을 비교합니다.

---
## 3차 질문

`Q. 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있나요?`

A. 오버라이딩은 상위 클래스의 메소드를 재정의 하는 것을 의미합니다. 또한 런타임 다형성이기도 합니다.

오버로딩은 같은 클래스 내에서 동일한 메소드 이름을 가지지만, 매개변수의 타입, 개수가 다르게 구현할 수 있는 것을 의미하며 컴파일 타임 다형성이기도합니다. 따라서 오버라이딩 될 수 있습니다.

`Q. 오버라이딩 시 지켜야 할 규칙이 있을까요?`

A. 먼저 메서드의 선언부는 부모 클래스의 메서드와 완전히 동일해야하며, 접근 제어자는 부모 클래스의 메서드보다 더 좁은 범위로 변경할 수 없습니다. 그리고 예외는 부모 클래스의 메서드보다 더 큰 범위의 예외를 던질 수 없습니다.

`Q. 오버라이딩 할 때 어노테이션을 사용하는데 이유가 무엇인가요?`

A. 가장 큰 이유는 컴파일 시점에 오버라이딩이 제대로 되었는 지 검증할 수 있기 때문입니다. 메서드 이름, 매개변수 타입을 다르게 작성하는 실수가 있을 때 어노테이션이 없다면 이는 새로운 메서드를 정의한 것으로 인식되어 컴파일 에러가 발생하지 않습니다.

다만, 어노테이션을 사용한다면 제대로 오버라이딩 했는 지 검사하므로, 잘못 작성된 오류를 컴파일 에러를 통해 확인할 수 있게 됩니다.

`Q. private 메소드는 오버라이딩이 가능한가요?`

A. 아니오. 불가능합니다.

private 메소드는 해당 클래스 내에서만 접근 가능한 가장 높은 수준의 캡슐화를 제공합니다. 따라서 자식 클래스에서 부모 클래스의 private 메소드에 접근할 수 없습니다. 접근 자체가 불가능하므로 오버라이딩 또한 불가능합니다.

만약 자식 클래스에서 부모 클래스의 private 메소드와 동일한 이름의 매개변수로 메소드를 정의한다면, 이는 오버라이딩이 아닌 새로운 메소드를 정의하게 됩니다.