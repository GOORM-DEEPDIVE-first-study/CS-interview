## 질문 주제: 데이터베이스

## Q1. 인덱스를 사용하는 이유에 대해 설명해 주세요.

> a. 인덱스는 데이터 검색 성능을 향상 시키기 위해 사용됩니다. 데이터베이스에서 특정 데이터를 찾을 때, 인덱스가 없으면 모든 데이터를 처음부터 끝까지 탐색해야 하지만, 인덱스를 사용하면 원하는 데이터를 훨씬 빠르게 찾을 수 있습니다. 인덱스는 책의 목차나 색인과 비슷한 역할을 합니다. 예를 들어, 수천만 개의 데이터 중에서 특정 사용자의 정보를 찾을 때, 인덱스를 사용하면 탐색 범위가 줄어들어 성능이 향상됩니다. 하지만 인덱스는 추가적인 저장 공간을 차지하고, 데이터가 변경될 때마다 인덱스도 갱신해야 하므로, 모든 경우에 적절한 것은 아닙니다. 일반적으로 조회가 빈번한 컬럼에 인덱스를 적용하는 것이 효과적입니다.

###  Q1-1. 인덱스를 무조건 많이 만들면 성능이 좋아지나요?
아닙니다. 인덱스가 많아질수록 조회 성능은 좋아질 수 있지만, 그만큼 추가적인 저장 공간이 필요하고, 데이터 삽입, 수정, 삭제 시 인덱스도 함께 갱신해야 하므로 성능이 저하될 수 있습니다. 따라서 조회 빈도가 높은 컬럼에 적절히 인덱스를 설정하는 것이 중요합니다.

### Q1-2. B-Tree 인덱스와 Hash 인덱스의 차이점은 무엇인가요?
B-Tree 인덱스는 데이터를 계층적으로 정렬하여 범위 검색이 가능하고, 대부분의 RDBMS에서 기본적으로 사용됩니다. 반면, Hash 인덱스는 키-값 기반으로 데이터를 빠르게 찾을 수 있지만, 범위 검색이 어렵습니다. 따라서 WHERE 절에서 ‘=’ 조건을 자주 사용한다면 Hash 인덱스가 유리하지만, 범위 검색이 필요하다면 B-Tree 인덱스가 더 적합합니다.

## Q2. RDBMS와 NoSQL의 차이점에 대해 설명해 주세요.

> a. RDBMS는 관계형 데이터베이스로, 데이터를 테이블 형태로 저장하며, 명확한 스키마를 요구하고 SQL을 사용합니다. 반면, NoSQL은 스키마가 없거나 유연하며, 키-값, 문서, 컬럼 기반 등 다양한 데이터 모델을 지원합니다.
RDBMS는 데이터의 일관성이 중요한 금융 시스템이나 기업 ERP와 같은 환경에서 주로 사용됩니다. 반면, NoSQL은 대량의 데이터를 빠르게 처리해야 하는 빅데이터, 소셜 미디어, IoT와 같은 분야에서 많이 활용됩니다. 특히 NoSQL은 수평 확장(Scale-Out)에 유리하여 대규모 트래픽을 처리할 때 강점을 가집니다.
 
### Q2-1. RDBMS와 NoSQL 중 어느 것을 선택해야 하나요?
데이터의 무결성과 일관성이 중요하다면 RDBMS를 선택하는 것이 좋고, 대량의 데이터를 빠르게 처리해야 하거나 유연한 데이터 구조가 필요하다면 NoSQL이 적합합니다. 예를 들어, 은행 시스템은 RDBMS가 적합하고, SNS 피드 저장 같은 경우 NoSQL이 더 효과적일 수 있습니다. 상황과 방향성에 따라 선택을 하여야 하며 무조건 적인 정답은 없다고 생각합니다.

### Q2-2. NoSQL도 트랜잭션을 지원하나요?
일반적으로 RDBMS는 ACID 트랜잭션을 보장하지만, NoSQL은 BASE 원칙을 따르기 때문에 일관성이 다소 약할 수 있습니다. 하지만 MongoDB나 Cassandra 같은 일부 NoSQL 데이터베이스는 트랜잭션을 지원하는 기능을 제공하기도 합니다.

## Q3. 트랜잭션에 대해 설명해 주세요.

> a. 트랜잭션은 데이터베이스에서 하나의 작업 단위로 실행되는 연산의 집합입니다. 예를 들어, 은행에서 한 계좌에서 돈을 출금하고 다른 계좌로 입금하는 경우, 두 개의 연산이 모두 성공해야 트랜잭션이 완료됩니다. 만약 하나의 연산만 성공하고 다른 연산이 실패하면, 데이터의 불일치가 발생할 수 있기 때문에 트랜잭션을 사용하여 모든 작업을 한꺼번에 처리하거나, 실패 시 원래 상태로 복구(ROLLBACK)해야 합니다.

### Q3-1. 트랜잭션이 적용되지 않으면 어떤 문제가 발생하나요?
트랜잭션이 적용되지 않으면 데이터의 정합성이 깨질 수 있습니다. 예를 들어, 계좌 이체 중에 시스템 오류가 발생하여 출금은 되었지만 입금이 되지 않는다면 심각한 문제가 발생할 수 있습니다.

### Q3-2. 트랜잭션 격리 수준(Isolation Level)에 대해 설명해 주세요.
트랜잭션 격리 수준은 여러 트랜잭션이 동시에 실행될 때 서로 간섭하지 않도록 하는 정도를 조절하는 개념입니다. 대표적인 격리 수준은 다음과 같습니다.
- Read Uncommitted: 다른 트랜잭션에서 아직 커밋되지 않은 데이터를 읽을 수 있음 → 데이터 정합성 문제 발생 가능
- Read Committed: 커밋된 데이터만 읽을 수 있음 → Dirty Read 방지
- Repeatable Read: 같은 트랜잭션 내에서 동일한 데이터를 읽을 때 값이 변하지 않음 → "반복 가능한 읽기" 보장
- Serializable: 가장 엄격한 격리 수준으로, 트랜잭션이 직렬적으로 실행됨 → 동시성이 낮아지지만, 데이터 정합성을 가장 잘 보장

## Q4. ACID에 대해 설명해 주세요.

> a. ACID는 데이터베이스 트랜잭션의 신뢰성을 보장하는 네 가지 핵심 원칙입니다.
Atomicity (원자성): 트랜잭션은 모두 실행되거나, 전혀 실행되지 않아야 합니다.
Consistency (일관성): 트랜잭션 실행 전후에 데이터의 무결성이 유지되어야 합니다.
Isolation (고립성): 여러 트랜잭션이 동시에 실행될 때 서로 간섭하지 않아야 합니다.
Durability (지속성): 트랜잭션이 성공적으로 완료되면 데이터는 영구적으로 저장되어야 합니다.
예를 들어, 은행 계좌 이체 트랜잭션에서 한 계좌에서 출금 후 다른 계좌에 입금이 정상적으로 처리되도록 보장하는 것이 ACID 원칙을 준수하는 것입니다.
 
### Q4-1. ACID를 보장하기 위해 데이터베이스에서는 어떤 기술을 사용하나요?
대표적으로 WAL(Write-Ahead Logging), MVCC(Multi-Version Concurrency Control), 락(Locking) 등의 기술을 사용합니다. WAL은 트랜잭션 로그를 먼저 기록하여 장애 발생 시 복구할 수 있도록 하고, MVCC는 동시성을 높이면서도 데이터 정합성을 유지하는 방법입니다.

### Q4-2. NoSQL 데이터베이스는 ACID를 지원하지 않나요?
기본적으로 NoSQL은 BASE(Basically Available, Soft state, Eventually consistent) 모델을 따르기 때문에 ACID를 완벽하게 보장하지 않는 경우가 많습니다. 하지만 일부 NoSQL 시스템(MongoDB, Amazon DynamoDB 등)은 제한적인 범위에서 ACID를 지원하기도 합니다.

## Q5. 조인(JOIN)과 그 종류를 설명하세요.
> 조인은 두 개 이상의 테이블을 연결하여 데이터를 조회하는 방식입니다. 대표적인 조인 방식은 다음과 같습니다.
INNER JOIN: 두 테이블에서 공통된 값을 가진 데이터만 반환.
LEFT JOIN: 왼쪽 테이블의 모든 행을 반환하고, 오른쪽 테이블에 일치하는 값이 없으면 NULL을 반환.
RIGHT JOIN: 오른쪽 테이블의 모든 행을 반환하고, 왼쪽 테이블에 일치하는 값이 없으면 NULL을 반환.
FULL OUTER JOIN: 두 테이블의 모든 데이터를 반환하고, 일치하는 값이 없는 경우 NULL로 채움.
CROSS JOIN: 두 테이블의 모든 데이터를 조합하여 반환(카테시안 곱).

### Q5-1. INNER JOIN과 LEFT JOIN 중 어느 것이 더 성능이 좋나요?
INNER JOIN이 일반적으로 성능이 더 좋습니다. LEFT JOIN은 NULL 값을 처리해야 하므로 성능이 상대적으로 떨어질 수 있습니다.

### Q5-2. 조인과 서브쿼리(Subquery)의 차이점은?
조인은 여러 테이블을 연결하여 데이터를 조회하는 방식이고, 서브쿼리는 하나의 SQL문 내에 또 다른 SQL문을 포함하는 방식입니다. 일반적으로 조인이 성능 면에서 더 우수할 수 있습니다.